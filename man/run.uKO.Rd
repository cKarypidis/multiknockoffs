% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/run.uKO.R
\name{run.uKO}
\alias{run.uKO}
\title{Union knockoff filter}
\usage{
run.uKO(
  X,
  y,
  knockoffs = create.second_order,
  statistic = stat.glmnet_coefdiff,
  qk = "decseq",
  q = 0.2,
  K = 5,
  q_seq = NULL,
  offset = 1,
  sets = F
)
}
\arguments{
\item{X}{n x p matrix or data frame of original variables.}

\item{y}{response vector of length n.}

\item{knockoffs}{function for the knockoff construction. It must take the n x p matrix as input
and it must return a n x p knockoff matrix. Either choose a knockoff sampler of
the \code{knockoff} package or define it manually. Default: \code{create.second_order} (see below).}

\item{statistic}{function that computes the score vector \eqn{W} of length p. It must take the data matrix,
knockoff matrix and response vector as input and outputs a vector of computed
scores. Either choose one score statistic from the \code{knockoff} package or
define it manually. Default: \code{stat.glmnet_coefdiff} (see below).}

\item{qk}{sequence of nominal levels. Either choose \code{"decseq"} (default) for \eqn{q_{k} = q/2^{k-1}}
or \code{"ave"} for \eqn{q_{k} = q/K}.}

\item{q}{nominal level for the FDR control. Default: 0.2.}

\item{K}{number of knockoff runs. Default: 5.}

\item{q_seq}{manual sequence of nominal level which has to match in length
with the number of knockoff runs \code{K}. If this argument is specified, \code{qk} and \code{q} are
ignored.}

\item{offset}{either 0 (knockoff) or 1 (knockoff+). Default: 1.}

\item{sets}{logical argument if the K selection sets of each knockoff run
should be returned. Default: \code{FALSE}.}
}
\value{
A list containing following components:
\item{Shat}{aggregated selection set.}
\item{K}{number of knockoff runs.}
\item{FDRbound}{theoretical FDR bound.}
\item{sets}{if specified, individual selection sets of each knockoff run.}
}
\description{
This function runs the whole union knockoff procedure, i.e. it generates multiple
knockoff matrices, estimates the score functions and the selection sets of multiple knockoff
runs, which are then aggregated by their union to obtain the final selection set.
}
\details{
This function requires the installation of the \code{knockoff} package prior to its execution.

The default knockoff sampler \code{create.second_order} is the second-order Gaussian knockoff construction from
the \code{knockoff} package.

The default score function \code{stat.glmnet_coefdiff} is from the \code{knockoff} package.
It fits a  Lasso regression where the regularization parameter \eqn{\lambda} is tuned by cross-validation.
Then, the score is computed as the difference between
\deqn{W_j = |Z_j| - |\tilde{Z}_j|}
where \eqn{Z_j} and \eqn{\tilde{Z}_j} are the coefficient estimates for the
jth variable and its knockoff, respectively.

The user has to specify either \code{qk} together with \code{q} to apply one of the pre-defined
nominal levels or has to define the argument \code{q_seq} for an own sequence of nominal levels.
}
\examples{
n <- 400; p <- 200; s_0 <- 30
amplitude <- 1; mu <- rep(0,p); rho <- 0.25
Sigma <- toeplitz(rho^(0:(p-1)))

X <- MASS::mvrnorm(n, mu, Sigma)
nonzero <- sample(p, s_0)
beta <- amplitude * (1:p \%in\% nonzero)
y <- X \%*\% beta + rnorm(n)

# Basic usage with default arguments
res.uKO <- run.uKO(X, y, sets = T)
res.uKO

# Advanced usage with customized knockoff construction (equi-correlated)
equi.knock <- function(X) create.second_order(X, method = "equi")
res.uKO <- run.uKO(X, y, knockoffs = equi.knock, sets = T)
res.uKO

}
\references{
Xie and Lederer (2021). \emph{Aggregating Knockoffs for False Discovery Rate Control with an Application to Gut Microbiome Data.}
Entropy 23(2), 230.
\url{https://www.mdpi.com/1099-4300/23/2/230/xml}
}
